{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"aboutme/","text":"Welcome to My Portfolio! \uf0c1 About Me \uf0c1 Hi there! My name is Temidayo Azeez . I am a Technical Writer and Content Marketer . Technical Writing \uf0c1 As a technical writer, I create technical content and documentation around developer tools and frameworks , product and APIs , on technical topics , as well as, opinion posts and thought leadership content related to technical writing and software engineering. I am skilled at creating technical documentation with several authoring tools, such as Mkdocs , Sphinx , Jeckll and Readthedocs . I create the following technical writing content deliverables: Technical overview Installation/setup/configuration guide Getting started/Hello World Tutorials (training materials) How-To's (Recipes and cookbooks) Reference guides (Web APIs) Thought leadership content/Opinion posts on technical topics (blogposts and articles) Content Marketing \uf0c1 As a content marketer, I am able to deploy my storytelling , argumentative , and content creation skills to create compelling content that appeals to target audience (reader-content fit) , addresses their specific pain-points (specificity) , then communicate the unique value proposition of a product aimed towards solving those specific user/customer problems (originality) . I am also skilled at SEO (search engine optimization) to ensure content discoverability on search engine. With content marketing, I am skilled at using the funnel framework(TOFU, MOFU, BOFU) for content creation. I create the following content marketing content types: Thought leadership content (TOFU, MOFU) How-to posts (TOFU, MOFU, BOFU) Opinion posts (TOFU, MOFU) Customer success stories/Usecases (BOFU) Comparison blogposts (BOFU) Info TOFU, MOFU, BOFU means top-of-the-funnel content, middle-of-the-funnel content, and bottom-of-the-funnel content respectively. Info It should be noted that the \"how-to\" marketing content type is fundamentally different from \"how-to's\" as it exist in technical writing. Check out my Medium blog to review some of my content marketing content (thought leadership content and comparison blogpost). Click here . View some of my TOFU content pieces here . View a BOFU (bottom-of-the-funnel) content piece here . My Socials \uf0c1 Gmail: temidayoazeez032 @gmail .com LinkedIn: https://www.linkedin.com/in/knowledgeissweet/ Github: https://github.com/Temidayo32 Twitter: https://twitter.com/Temiday62034939","title":"Home"},{"location":"aboutme/#welcome-to-my-portfolio","text":"","title":"Welcome to My Portfolio!"},{"location":"aboutme/#about-me","text":"Hi there! My name is Temidayo Azeez . I am a Technical Writer and Content Marketer .","title":"About Me"},{"location":"aboutme/#technical-writing","text":"As a technical writer, I create technical content and documentation around developer tools and frameworks , product and APIs , on technical topics , as well as, opinion posts and thought leadership content related to technical writing and software engineering. I am skilled at creating technical documentation with several authoring tools, such as Mkdocs , Sphinx , Jeckll and Readthedocs . I create the following technical writing content deliverables: Technical overview Installation/setup/configuration guide Getting started/Hello World Tutorials (training materials) How-To's (Recipes and cookbooks) Reference guides (Web APIs) Thought leadership content/Opinion posts on technical topics (blogposts and articles)","title":"Technical Writing"},{"location":"aboutme/#content-marketing","text":"As a content marketer, I am able to deploy my storytelling , argumentative , and content creation skills to create compelling content that appeals to target audience (reader-content fit) , addresses their specific pain-points (specificity) , then communicate the unique value proposition of a product aimed towards solving those specific user/customer problems (originality) . I am also skilled at SEO (search engine optimization) to ensure content discoverability on search engine. With content marketing, I am skilled at using the funnel framework(TOFU, MOFU, BOFU) for content creation. I create the following content marketing content types: Thought leadership content (TOFU, MOFU) How-to posts (TOFU, MOFU, BOFU) Opinion posts (TOFU, MOFU) Customer success stories/Usecases (BOFU) Comparison blogposts (BOFU) Info TOFU, MOFU, BOFU means top-of-the-funnel content, middle-of-the-funnel content, and bottom-of-the-funnel content respectively. Info It should be noted that the \"how-to\" marketing content type is fundamentally different from \"how-to's\" as it exist in technical writing. Check out my Medium blog to review some of my content marketing content (thought leadership content and comparison blogpost). Click here . View some of my TOFU content pieces here . View a BOFU (bottom-of-the-funnel) content piece here .","title":"Content Marketing"},{"location":"aboutme/#my-socials","text":"Gmail: temidayoazeez032 @gmail .com LinkedIn: https://www.linkedin.com/in/knowledgeissweet/ Github: https://github.com/Temidayo32 Twitter: https://twitter.com/Temiday62034939","title":"My Socials"},{"location":"opinion_posts/technical_marketers/","text":"Why Technical Writers Should be called Technical Marketers \uf0c1 Info Originally published on LinkedIn here Technical Marketers. I know the term sounds weird (is that even a good word blend?). I couldn't figure the right term that makes the best sense, but for the purpose of this article, the word blend would work just fine (feel free to suggest a better one in the comments). That said, let's get to the purpose of this article. Recently, on LinkedIn, I observed a discussion relevant to technical writers that I believe have never been broached or discussed among technical writers\u2014at least, not a widespread discussion. Here is a snapshot of some of the posts. The motivation and reasoning behind these posts are simple: crediting technical writers with their true worth . Traditionally, discussions around increasing leads, converting leads, and improving ROI have largely been attributed to efforts of the marketing and sales teams in an organization. But what about technical writers? Does documentation produced by technical writers contribute nothing to the ROI bucket? Let\u2019s go back in time and bring in some backstory\u2026 With the rise and maturation of the B2B SaaS space, and the consequent boom of APIs, API and product documentation have become even more important elements in most B2B SaaS companies, especially developer-facing B2B SaaS companies. It is common knowledge today that for an API to be labelled \"good\", then it must be with a \"good\" documentation. Tom Johnson, owner of idratherbewriting.com, has this in his API documentation course. \u201cWhy are developers not using your APIs? \u2026 because your documentation sucks.\u201d Aside from Tom Johnson, data, research, and studies over time have confirmed this fact over and over again: without good documentation, developers will not use your API. Simple. Period. Now, this fact raises some disturbing questions about how documentation\u2014and technical writers (I will get this later on in the post)\u2014is perceived. Till now, documentation is mostly perceived as a \"necessary evil\" or simply \"following standards\" or as a \"reference guide for developers\" and the list could run. But here is my point, if documentation is so important to convince developers to use an API, isn't it high time it is added to documentation the important role it also plays in marketing? I know this may sound weird. When we think of marketing content, we think of copywriting, of showing all the \u201cgoods\u201d about your product (API), talking about all the benefits of your API, how your product is better than its competitors, and saying little to nothing about the limitations of your product. It could be hard seeing a technical documentation as a marketing content: it's bare bone nature, and it's almost lack, most times, of any mention of benefits (more emphasis on description of features than talking about their benefits), and the ever presence of limitations, inabilities, and \u201clack of certain functionalities\u201d (that may be critical to certain potential users) of the product scattered throughout the documentation. But interestingly, it is this very nature of technical documentation (transparency) that makes it very attractive to developers and API users. While conventional marketing content would be labelled high quality based on how best they are able to convey the benefits of a product, technical documentation would be labelled high quality based on its transparency\u2014technical writers are called user-advocates for a good reason . Technical documentation helps developers get past conventional marketing content that are constantly trying to sell them, and get to assess the product for themselves: to get all the information they need to make the best decisions; to determine the worth of the product for themselves based on their own terms and needs, not based on the values and benefits communicated by conventional marketing content. In summary, as opposed to conventional marketing content, technical documentation is what you might think of as a \"completely transparent\" marketing content . And that makes a lot of sense if you think about it. If the goal of conventional marketing content is to convert leads into customers towards growing your ROI; and the goal of technical documentation is towards improving the attractiveness of your API in order to increase adoption by developers, hence converting them (leads) to users of your API(customers), with the end goal of growing your ROI just like conventional marketing content, I don't see any reason why technical documentation can't be perceived also as marketing content. Transparent marketing content, specifically. That said, what position in organizations/businesses/companies does this leave the \"brains\" (technical writers) behind technical documentation? For a long time, Technical writers have existed in the background. Companions of developers. Necessary evils. It has never been attributed to them the role they also play in contributing to the ROI bucket. To the best of my knowledge, from discussion I have observed on LinkedIn with experts that have stayed long in the field, technical writers have not been fully acknowledged for the important roles they play, at least, not for the part they play in growing ROI. If technical documentation is also marketing content as I argued, and hence, plays a key role in lead conversion into customers, then technical writers also deserve to be honored and credited, in the same manner as the marketing and sales teams, with their contribution to the ROI bucket. Now, you might wonder, what could be the possible benefits of this? Of recognizing and crediting technical writers with their contribution to the ROI bucket? I will give you some: An instant benefit is that it would bring technical writers out from the background and plant them in the spotlight to become a part of key decision authorities in any business organization. The consequent benefit of this is exponential: increase in the working condition of technical writers; an ability of technical writers to also table directly \"their needs\" instead of depending on the CTO or on other authority figures that would mostly delay attention to their needs (bureaucracy) and more. As a beginner, my ability to expound on the benefits of \"bringing technical writers to the decision table\" by endorsing their important contribution to ROI is limited. But I trust experts technical writers reading this post right now and have spent a long time working as technical writers would have a wide girth of experience to enable them to stretch the benefit possibilities of this way further. So let me know in the comments, what are some of the benefits to technical writers of endorsing their contribution to ROI, and consequently, the benefits to technical writers of being a part of the decision table. Note: This post is an opinion post and it is by no means an ultimate source.","title":"Why Technical Writers Should be called Technical Marketers"},{"location":"opinion_posts/technical_marketers/#why-technical-writers-should-be-called-technical-marketers","text":"Info Originally published on LinkedIn here Technical Marketers. I know the term sounds weird (is that even a good word blend?). I couldn't figure the right term that makes the best sense, but for the purpose of this article, the word blend would work just fine (feel free to suggest a better one in the comments). That said, let's get to the purpose of this article. Recently, on LinkedIn, I observed a discussion relevant to technical writers that I believe have never been broached or discussed among technical writers\u2014at least, not a widespread discussion. Here is a snapshot of some of the posts. The motivation and reasoning behind these posts are simple: crediting technical writers with their true worth . Traditionally, discussions around increasing leads, converting leads, and improving ROI have largely been attributed to efforts of the marketing and sales teams in an organization. But what about technical writers? Does documentation produced by technical writers contribute nothing to the ROI bucket? Let\u2019s go back in time and bring in some backstory\u2026 With the rise and maturation of the B2B SaaS space, and the consequent boom of APIs, API and product documentation have become even more important elements in most B2B SaaS companies, especially developer-facing B2B SaaS companies. It is common knowledge today that for an API to be labelled \"good\", then it must be with a \"good\" documentation. Tom Johnson, owner of idratherbewriting.com, has this in his API documentation course.","title":"Why Technical Writers Should be called Technical Marketers"},{"location":"tutorial/django_tutorial/","text":"Creating a Django Story App \uf0c1 Info Check out the source code on GitHub here In this tutorial, you learn to create a simple story app that allows you the following functionalities: A public site that allows you to view and search a story list, and read story content. An admin site that lets you add, change, and delete stories, categories and tags. Prerequisites & Installations \uf0c1 Prerequisites \uf0c1 This tutorial is for beginners to the Django framework\u2014although not for absolute beginners. If this is your first attempt at Django, I will strongly recommend perusing first the Django tutorial as it is more detailed. It will help you get familiar with the framework before you try out your hand on other fun/practice projects. The following prerequites are also required: Comfortable using the command line Installation of Python3, preferably version 3.8 and above. An understanding of the OOP(Object-oriented programming) paradigm. Setting Up your Development Workstation \uf0c1 In this tutorial, we would be setting up our Django project in a virtual environment\u2014inline with best practices. Navigate to your working directory\u2014using command line/powershell\u2014on your local machine and carry out the following instructions. Create a new virtual environment Enter the virtual environment Activate the virtual environment It should appear similar to this in your command line: .../> virtualenv <name> <!--name: storybook --> .../> cd <name> .../<name>/> scripts/activate Now, install the following: Django Django-taggit Info This tutorial is written based on the lastest Django version at the time, which is version 4.0.6. For the purpose of this tutorial, I will advise you install this version. Caution Ensure your virtual environment is activated when installing Django-taggit. Failure to do so might trigger a ModuleNotFoundError: No module named 'taggit' when making migrations later on in the project. With out development environment set up, let's create our django project. Creating a Project \uf0c1 If you have done the django tutorial , you should be familiar with initiating a new django project. django-admin startproject <name> <!-- name: story --> The command should create this directory structure: storybook <!--name of the project created (outer directory)--> \u2502 manage.py \u2502 \u2514\u2500\u2500\u2500storybook <!-- inner directory --> asgi.py settings.py urls.py wsgi.py __init__.py Info You can run the python manage.py runserver to confirm your project is well set-up. The development server should run in your browser. You should see a rocket shooting flames downward about to take off, and a bold message: The install worked successfully! Congratulations! Creating an App \uf0c1 Next, create an app in your Django project. It should be in the outer directory, on the same level with the inner directory. django-admin startapp <name> The command should create this directory structure: story \u2502 admin.py \u2502 apps.py \u2502 models.py \u2502 tests.py \u2502 views.py \u2502 __init__.py \u2502 \u2514\u2500\u2500\u2500migrations __init__.py With that done, we would update INSTALLED_APPS within our settings.py to notify Django about our newly created app. Info Recall we installed Django-taggit at the beginning of the tutorial? We need the plugin for creating and managing our story tags. Alongside your app, add taggit to INSTALLED_APPS . <!--storybook/settings.py --> INSTALLED_APPS = [ ... \"story.apps.StoryappConfig\", \"taggit\", ] Next up, we would add our app to the urls.py in our project directory. To do that, first, we would create a urls.py file in our app. Next, we navigate to our project urls file and modify it to reflect this: <!-- storybook/urls.py --> from django.contrib import admin from django.urls import path, include <!-- new --> from argparse import Namespace <!-- new --> urlpatterns = [ path('admin/', admin.site.urls), path('story/', include(('story.urls', 'story'), namespace='story')), <!-- new --> ] Having done that, now we can run our first migrations. These commands creates a database for our project. For convenience, we would be using the default database (Sqlite) Django have provided us. .../> python manage.py makemigrations .../> python manage.py migrate Note When working on your own, you can decide to modify your url files much later on after making migrations or even after you've created some models and views. The order doesn't matter. Creating Models \uf0c1 Our app will have two models: Category and Story . Category will have two fields: name and slug . Story will have five fields: category , title , des , body and tag . Finally, we would add a Meta class and a __str__ function to each of the models. Modify your app's models.py to reflect this: <!-- story/models.py --> from django.db import models from django.urls import reverse from taggit.managers import TaggableManager # Create your models here. class Category(models.Model): name=models.CharField(max_length=150, db_index=True,) slug=models.SlugField(unique=True) class Meta: ordering= ('-name',) def __str__(self): return self.name class Story(models.Model): category=models.ForeignKey(Category, on_delete=models.CASCADE) title=models.CharField(max_length=150) body=models.TextField() des=models.TextField() publish=models.DateTimeField(auto_now_add=True) tags=TaggableManager() class Meta: ordering=('-publish',) def __str__(self): return self.title Now, we must run migrations again to create database tables for our models. Having done that, we would modify our app's admin.py to enable us create, modify and delete instances of our model classes from the admin. First, we would import models into our app's admin.py .Then, we would add ModelAdmin classes to register our models in the admin. In this tutorial, we would also use register decorators on each of the ModelAdmin classes. Modify your app's admin.py to reflect this: <!-- story/admin.py --> from django.contrib import admin from .models import Category, Story @admin.register(Category) class CategoryAdmin(admin.ModelAdmin): list_display=['name','slug'] @admin.register(Story) class StoryAdmin(admin.ModelAdmin): list_display=['title','publish'] search_fields=['title',] Defining Urls \uf0c1 Without our urls defined, we would not be able to access our web application from a browser. In preparation for the next step (creating objects), we would define our first url path to allow us create instances of our model classes from within the admin interface. Navigate to your story app urls.py and modify it to reflect this: <!-- story/urls.py --> from django.contrib import admin from django.urls import path app_name = 'story' urlpatterns = [ path('admin/', admin.site.urls), ] Note You won't be able to view your admin if haven't created your user yet. To create a user, run this command in your command line: python manage.py createsuperuser . Thereafter, you should be able to login from your local domain using this url: http://127.0.0.1:8000/admin/ . You should be able to see your Story app, alongside the models, displayed on the admin page on login. Creating Objects \uf0c1 At this point, you should be able to create instances of your models from within your admin. Creating categories Creating stories Go ahead and create instances of your model classes. The data from this exercise will come handy when writing our views. Writing Views \uf0c1 With a couple instances of our models now stored in the database, we can the views. In this tutorial, we would only be writing function-based views. In your views.py , we would create our first function-based view that allows us to display in a browser, a list of stories, alongside a search funtionality implemented to allows us search the list of stories by title , des , body , and tags . Now, modify your views.py to reflect this: <!-- story/views.py --> from queue import Empty from django.shortcuts import render, get_object_or_404 from django.db.models import Q from .models import Category, Story def story_list(request): query=None category=None stories=Story.objects.all() story= [] if request.method==\"GET\": query= request.GET.get(\"search\") if query: story=Story.objects.filter(Q(title__icontains=query) | Q(body__icontains=query)| Q(des__icontains=query)|Q(tags__name__iregex=query)).distinct() return render(request, 'story/story_list.html', { 'story': story, 'category': category, 'stories': stories, 'query':query, }) Creating Templates \uf0c1 If have not done so before, go ahead and create a templates directory in your story app. Then, create a sub-directory with the name, \"story\", in your templates directory. Caution Make sure your templates directory's name is \"templates\". This is line with best practice when using Django for web applications. The Django engine knows automatically to look into your templates directory to discover your template files. Having done that we would create a base.html template. This will hold nav and footer since we expect both to repeat across all pages on our website. Create a base.html in your story sub-directory. Then modify it to reflect this: <!-- templates/story/base.html --> <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"utf-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <title></title> <meta name=\"description\" content=\"\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"> {% comment %} Bootstrap CSS {% endcomment %} <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css\" integrity=\"sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk\" crossorigin=\"anonymous\"> {% block title %} <title>story book</title> {% endblock title %} </head> <body> {% comment %}As a heading {% endcomment %} <nav class=\"navbar navbar-dark bg-dark\"> <a href=\"{% url 'story:story_list' %}\"><span class=\"navbar-brand mb-0 h1\">Story book</span></a> </nav> {% block body %} {% endblock body %} <foooter class=\"cs-footer mt-4 bg-dark pt-5 pt-md-6 pt-lg-7\"> <div class=\"container pt-3 pt-md-0\"> <div class=\"pb-md-4 text-center\"> <h3 class=\"text-light font-weight-light mb-3\">Do not read all story?</h3> <h2 class=\"text-light mb-5\">Read all story for your interest</h2> </div> </div> </footer> {% comment %} Optional Javascript {% endcomment %} <!-- jQuery first, then Popper.js, then Bootstrap JS --> {% comment %} <script src=\"static/tiny.js\"></script> {% endcomment %} <script src=\"https://code.jquery.com/jquery-3.5.1.slim.min.js\" integrity=\"sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj\" crossorigin=\"anonymous\"></script> <script src=\"https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js\" integrity=\"sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo\" crossorigin=\"anonymous\"></script> <script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js\" integrity=\"sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI\" crossorigin=\"anonymous\"></script> </body> </html> Next, we would create the template file for our story_list function view we wrote earlier. Go ahead and create a new template in the story sub-directory with the name, \"story_list\". Now, modify it to reflect this: <!-- templates/story/story_list.html --> {% extends \"story/base.html\" %} {% block title %} <title>story book</title> {% endblock title %} {% block body %} <div class=\"pricing-header px-3 py-3 pt-mt-5 pb-md-4 mx-auto text-center\"> <h1 class=\"display-4\">Story book</h1> <p class=\"lead\">you can find here some short stories</p> <form type=\"get\" action=\"#\"> {% csrf_token %} <label>Location:-</label> <input id=\"search\" type=\"text\" name=\"search\" placeholder=\"Search...\"> <button type=\"submit\">Submit</button> </form> {% if query %} <h3>{% with story.count as total_results %} Found {{total_results}} results {% endwith %} </h3> {% for x in story %} <div class=\"mt-3\"> <li style=\"list-style: none;\"><a href=\"{{x.get_absolute_url}} \"><h3>{{x.title}} </h3></a></li> <p>{{x.des}} </p> </div> {% empty %} <h3>There is no query</h3> {% endfor %} {% else %} <div class=\"mt-3\"> <ul style=\"list-style: none;\"> {% for story in stories %} <li><a href=\"{{story.get_absolute_url}}\"><h3>{{story.title}}</h3> </a></li> <p>{{story.des}} </p> {% endfor %} </ul> </div> {% endif %} </div> {% endblock body %} Info The get_absolute_url function in the template might trigger an error. That is because we have not defined the function yet. Don't worry. We would get to it shortly. The story_list.html template allows us to view and search the story list, but it doesn't allow us to view each story's details (story body). To view each story's details, we would create a new template with the name, \"story_detail\", in the story sub-directory. Having done that, modify the template to reflect this: <!-- templates/story/story_detail.html --> {% extends \"story/base.html\" %} {% block title %} <title>{{story.title}} </title> {% endblock title %} {% block body %} <div class=\"container\"> <h2 class=\"text-center\">{{story.title}} </h2><hr> <p class='lead'>{{story.body|safe}} </p> </div> <hr> <div class=\"container\"> <h2>YOU MAY ALSO LIKE:</h2> {% for x in like_story %} <a href=\"{{x.get_absolute_url}}\"><h5>{{x.title}}</h5></a> {% endfor %} <br> </div> <h2>Similar Posts</h2> {% for post in similar_posts %} <p> <a href=\"{{post.get_absolute_url}} \">{{post.title}} </a> </p> {% empty %} There are no similar story yet. {% endfor %} {% endblock body %} Modifying Views \uf0c1 We have a template for our story details. Consequently, we need to create a corresponding function view for it. Now, modify your views.py to reflect this: <!-- story/views.py --> import random <!-- new --> from taggit.models import Tag <!--new --> from taggit.managers import TaggableManager <!--new- --> def story_detail(request, id): story=get_object_or_404(Story, id=id) all_story=list(Story.objects.exclude(id=id)) like_story=random.sample(all_story,3) # Tags posts=Story.objects.get(id=id) similar_posts=posts.tags.similar_objects()[:2] return render(request, 'story/story_detail.html', {'story': story, 'like_story':like_story, 'similar_posts': similar_posts,}) Modifying Models \uf0c1 In the Story model, we would define a function that allows us to view the details of each story when we click each story in the story list. In your models.py , modify your Story model to reflect this: <!-- story/models.py --> Class Story(models.Model): ... def get_absolute_url(self): return reverse(\"story:story_detail\", args=[self.id,]) Modifying Urls \uf0c1 Now, we must define the urls to allow us access our web application in a browser. Navigate to your story app urls.py and modify it to include this: <!-- story/urls.py --> from . import views <!--new --> urlpatterns = [ ... path('', views.story_list, name='story_list'), path('<int:id>/',views.story_detail, name='story_detail'), ] The views.story_list allows us to view the story list using the http://127.0.0.1:8000/story path; views.story_detail allows us to view each story's details using the http://127.0.0.1:8000/storyapp/<int:id>/ path. With all that done, you should have a two page website up in your browser that allows you to view and search through a story list, then, view each story detail. Wrapping it Up \uf0c1 Congratulations, you've successfully created a simple Story app. If you run into any issues or error while following this tutorial, feel free to refer to the source code . I hope this was able to whet your appetite on the possibilities with the Django framework and get your creative juices flowing. Keep up the coding spirit!","title":"Django Tutorial"},{"location":"tutorial/django_tutorial/#creating-a-django-story-app","text":"Info Check out the source code on GitHub here In this tutorial, you learn to create a simple story app that allows you the following functionalities: A public site that allows you to view and search a story list, and read story content. An admin site that lets you add, change, and delete stories, categories and tags.","title":"Creating a Django Story App"},{"location":"tutorial/django_tutorial/#prerequisites-installations","text":"","title":"Prerequisites &amp; Installations"},{"location":"tutorial/django_tutorial/#prerequisites","text":"This tutorial is for beginners to the Django framework\u2014although not for absolute beginners. If this is your first attempt at Django, I will strongly recommend perusing first the Django tutorial as it is more detailed. It will help you get familiar with the framework before you try out your hand on other fun/practice projects. The following prerequites are also required: Comfortable using the command line Installation of Python3, preferably version 3.8 and above. An understanding of the OOP(Object-oriented programming) paradigm.","title":"Prerequisites"},{"location":"tutorial/django_tutorial/#setting-up-your-development-workstation","text":"In this tutorial, we would be setting up our Django project in a virtual environment\u2014inline with best practices. Navigate to your working directory\u2014using command line/powershell\u2014on your local machine and carry out the following instructions. Create a new virtual environment Enter the virtual environment Activate the virtual environment It should appear similar to this in your command line: .../> virtualenv <name> <!--name: storybook --> .../> cd <name> .../<name>/> scripts/activate Now, install the following: Django Django-taggit Info This tutorial is written based on the lastest Django version at the time, which is version 4.0.6. For the purpose of this tutorial, I will advise you install this version. Caution Ensure your virtual environment is activated when installing Django-taggit. Failure to do so might trigger a ModuleNotFoundError: No module named 'taggit' when making migrations later on in the project. With out development environment set up, let's create our django project.","title":"Setting Up your Development Workstation"},{"location":"tutorial/django_tutorial/#creating-a-project","text":"If you have done the django tutorial , you should be familiar with initiating a new django project. django-admin startproject <name> <!-- name: story --> The command should create this directory structure: storybook <!--name of the project created (outer directory)--> \u2502 manage.py \u2502 \u2514\u2500\u2500\u2500storybook <!-- inner directory --> asgi.py settings.py urls.py wsgi.py __init__.py Info You can run the python manage.py runserver to confirm your project is well set-up. The development server should run in your browser. You should see a rocket shooting flames downward about to take off, and a bold message: The install worked successfully! Congratulations!","title":"Creating a Project"},{"location":"tutorial/django_tutorial/#creating-an-app","text":"Next, create an app in your Django project. It should be in the outer directory, on the same level with the inner directory. django-admin startapp <name> The command should create this directory structure: story \u2502 admin.py \u2502 apps.py \u2502 models.py \u2502 tests.py \u2502 views.py \u2502 __init__.py \u2502 \u2514\u2500\u2500\u2500migrations __init__.py With that done, we would update INSTALLED_APPS within our settings.py to notify Django about our newly created app. Info Recall we installed Django-taggit at the beginning of the tutorial? We need the plugin for creating and managing our story tags. Alongside your app, add taggit to INSTALLED_APPS . <!--storybook/settings.py --> INSTALLED_APPS = [ ... \"story.apps.StoryappConfig\", \"taggit\", ] Next up, we would add our app to the urls.py in our project directory. To do that, first, we would create a urls.py file in our app. Next, we navigate to our project urls file and modify it to reflect this: <!-- storybook/urls.py --> from django.contrib import admin from django.urls import path, include <!-- new --> from argparse import Namespace <!-- new --> urlpatterns = [ path('admin/', admin.site.urls), path('story/', include(('story.urls', 'story'), namespace='story')), <!-- new --> ] Having done that, now we can run our first migrations. These commands creates a database for our project. For convenience, we would be using the default database (Sqlite) Django have provided us. .../> python manage.py makemigrations .../> python manage.py migrate Note When working on your own, you can decide to modify your url files much later on after making migrations or even after you've created some models and views. The order doesn't matter.","title":"Creating an App"},{"location":"tutorial/django_tutorial/#creating-models","text":"Our app will have two models: Category and Story . Category will have two fields: name and slug . Story will have five fields: category , title , des , body and tag . Finally, we would add a Meta class and a __str__ function to each of the models. Modify your app's models.py to reflect this: <!-- story/models.py --> from django.db import models from django.urls import reverse from taggit.managers import TaggableManager # Create your models here. class Category(models.Model): name=models.CharField(max_length=150, db_index=True,) slug=models.SlugField(unique=True) class Meta: ordering= ('-name',) def __str__(self): return self.name class Story(models.Model): category=models.ForeignKey(Category, on_delete=models.CASCADE) title=models.CharField(max_length=150) body=models.TextField() des=models.TextField() publish=models.DateTimeField(auto_now_add=True) tags=TaggableManager() class Meta: ordering=('-publish',) def __str__(self): return self.title Now, we must run migrations again to create database tables for our models. Having done that, we would modify our app's admin.py to enable us create, modify and delete instances of our model classes from the admin. First, we would import models into our app's admin.py .Then, we would add ModelAdmin classes to register our models in the admin. In this tutorial, we would also use register decorators on each of the ModelAdmin classes. Modify your app's admin.py to reflect this: <!-- story/admin.py --> from django.contrib import admin from .models import Category, Story @admin.register(Category) class CategoryAdmin(admin.ModelAdmin): list_display=['name','slug'] @admin.register(Story) class StoryAdmin(admin.ModelAdmin): list_display=['title','publish'] search_fields=['title',]","title":"Creating Models"},{"location":"tutorial/django_tutorial/#defining-urls","text":"Without our urls defined, we would not be able to access our web application from a browser. In preparation for the next step (creating objects), we would define our first url path to allow us create instances of our model classes from within the admin interface. Navigate to your story app urls.py and modify it to reflect this: <!-- story/urls.py --> from django.contrib import admin from django.urls import path app_name = 'story' urlpatterns = [ path('admin/', admin.site.urls), ] Note You won't be able to view your admin if haven't created your user yet. To create a user, run this command in your command line: python manage.py createsuperuser . Thereafter, you should be able to login from your local domain using this url: http://127.0.0.1:8000/admin/ . You should be able to see your Story app, alongside the models, displayed on the admin page on login.","title":"Defining Urls"},{"location":"tutorial/django_tutorial/#creating-objects","text":"At this point, you should be able to create instances of your models from within your admin. Creating categories Creating stories Go ahead and create instances of your model classes. The data from this exercise will come handy when writing our views.","title":"Creating Objects"},{"location":"tutorial/django_tutorial/#writing-views","text":"With a couple instances of our models now stored in the database, we can the views. In this tutorial, we would only be writing function-based views. In your views.py , we would create our first function-based view that allows us to display in a browser, a list of stories, alongside a search funtionality implemented to allows us search the list of stories by title , des , body , and tags . Now, modify your views.py to reflect this: <!-- story/views.py --> from queue import Empty from django.shortcuts import render, get_object_or_404 from django.db.models import Q from .models import Category, Story def story_list(request): query=None category=None stories=Story.objects.all() story= [] if request.method==\"GET\": query= request.GET.get(\"search\") if query: story=Story.objects.filter(Q(title__icontains=query) | Q(body__icontains=query)| Q(des__icontains=query)|Q(tags__name__iregex=query)).distinct() return render(request, 'story/story_list.html', { 'story': story, 'category': category, 'stories': stories, 'query':query, })","title":"Writing Views"},{"location":"tutorial/django_tutorial/#creating-templates","text":"If have not done so before, go ahead and create a templates directory in your story app. Then, create a sub-directory with the name, \"story\", in your templates directory. Caution Make sure your templates directory's name is \"templates\". This is line with best practice when using Django for web applications. The Django engine knows automatically to look into your templates directory to discover your template files. Having done that we would create a base.html template. This will hold nav and footer since we expect both to repeat across all pages on our website. Create a base.html in your story sub-directory. Then modify it to reflect this: <!-- templates/story/base.html --> <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"utf-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <title></title> <meta name=\"description\" content=\"\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"> {% comment %} Bootstrap CSS {% endcomment %} <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css\" integrity=\"sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk\" crossorigin=\"anonymous\"> {% block title %} <title>story book</title> {% endblock title %} </head> <body> {% comment %}As a heading {% endcomment %} <nav class=\"navbar navbar-dark bg-dark\"> <a href=\"{% url 'story:story_list' %}\"><span class=\"navbar-brand mb-0 h1\">Story book</span></a> </nav> {% block body %} {% endblock body %} <foooter class=\"cs-footer mt-4 bg-dark pt-5 pt-md-6 pt-lg-7\"> <div class=\"container pt-3 pt-md-0\"> <div class=\"pb-md-4 text-center\"> <h3 class=\"text-light font-weight-light mb-3\">Do not read all story?</h3> <h2 class=\"text-light mb-5\">Read all story for your interest</h2> </div> </div> </footer> {% comment %} Optional Javascript {% endcomment %} <!-- jQuery first, then Popper.js, then Bootstrap JS --> {% comment %} <script src=\"static/tiny.js\"></script> {% endcomment %} <script src=\"https://code.jquery.com/jquery-3.5.1.slim.min.js\" integrity=\"sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj\" crossorigin=\"anonymous\"></script> <script src=\"https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js\" integrity=\"sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo\" crossorigin=\"anonymous\"></script> <script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js\" integrity=\"sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI\" crossorigin=\"anonymous\"></script> </body> </html> Next, we would create the template file for our story_list function view we wrote earlier. Go ahead and create a new template in the story sub-directory with the name, \"story_list\". Now, modify it to reflect this: <!-- templates/story/story_list.html --> {% extends \"story/base.html\" %} {% block title %} <title>story book</title> {% endblock title %} {% block body %} <div class=\"pricing-header px-3 py-3 pt-mt-5 pb-md-4 mx-auto text-center\"> <h1 class=\"display-4\">Story book</h1> <p class=\"lead\">you can find here some short stories</p> <form type=\"get\" action=\"#\"> {% csrf_token %} <label>Location:-</label> <input id=\"search\" type=\"text\" name=\"search\" placeholder=\"Search...\"> <button type=\"submit\">Submit</button> </form> {% if query %} <h3>{% with story.count as total_results %} Found {{total_results}} results {% endwith %} </h3> {% for x in story %} <div class=\"mt-3\"> <li style=\"list-style: none;\"><a href=\"{{x.get_absolute_url}} \"><h3>{{x.title}} </h3></a></li> <p>{{x.des}} </p> </div> {% empty %} <h3>There is no query</h3> {% endfor %} {% else %} <div class=\"mt-3\"> <ul style=\"list-style: none;\"> {% for story in stories %} <li><a href=\"{{story.get_absolute_url}}\"><h3>{{story.title}}</h3> </a></li> <p>{{story.des}} </p> {% endfor %} </ul> </div> {% endif %} </div> {% endblock body %} Info The get_absolute_url function in the template might trigger an error. That is because we have not defined the function yet. Don't worry. We would get to it shortly. The story_list.html template allows us to view and search the story list, but it doesn't allow us to view each story's details (story body). To view each story's details, we would create a new template with the name, \"story_detail\", in the story sub-directory. Having done that, modify the template to reflect this: <!-- templates/story/story_detail.html --> {% extends \"story/base.html\" %} {% block title %} <title>{{story.title}} </title> {% endblock title %} {% block body %} <div class=\"container\"> <h2 class=\"text-center\">{{story.title}} </h2><hr> <p class='lead'>{{story.body|safe}} </p> </div> <hr> <div class=\"container\"> <h2>YOU MAY ALSO LIKE:</h2> {% for x in like_story %} <a href=\"{{x.get_absolute_url}}\"><h5>{{x.title}}</h5></a> {% endfor %} <br> </div> <h2>Similar Posts</h2> {% for post in similar_posts %} <p> <a href=\"{{post.get_absolute_url}} \">{{post.title}} </a> </p> {% empty %} There are no similar story yet. {% endfor %} {% endblock body %}","title":"Creating Templates"},{"location":"tutorial/django_tutorial/#modifying-views","text":"We have a template for our story details. Consequently, we need to create a corresponding function view for it. Now, modify your views.py to reflect this: <!-- story/views.py --> import random <!-- new --> from taggit.models import Tag <!--new --> from taggit.managers import TaggableManager <!--new- --> def story_detail(request, id): story=get_object_or_404(Story, id=id) all_story=list(Story.objects.exclude(id=id)) like_story=random.sample(all_story,3) # Tags posts=Story.objects.get(id=id) similar_posts=posts.tags.similar_objects()[:2] return render(request, 'story/story_detail.html', {'story': story, 'like_story':like_story, 'similar_posts': similar_posts,})","title":"Modifying Views"},{"location":"tutorial/django_tutorial/#modifying-models","text":"In the Story model, we would define a function that allows us to view the details of each story when we click each story in the story list. In your models.py , modify your Story model to reflect this: <!-- story/models.py --> Class Story(models.Model): ... def get_absolute_url(self): return reverse(\"story:story_detail\", args=[self.id,])","title":"Modifying Models"},{"location":"tutorial/django_tutorial/#modifying-urls","text":"Now, we must define the urls to allow us access our web application in a browser. Navigate to your story app urls.py and modify it to include this: <!-- story/urls.py --> from . import views <!--new --> urlpatterns = [ ... path('', views.story_list, name='story_list'), path('<int:id>/',views.story_detail, name='story_detail'), ] The views.story_list allows us to view the story list using the http://127.0.0.1:8000/story path; views.story_detail allows us to view each story's details using the http://127.0.0.1:8000/storyapp/<int:id>/ path. With all that done, you should have a two page website up in your browser that allows you to view and search through a story list, then, view each story detail.","title":"Modifying Urls"},{"location":"tutorial/django_tutorial/#wrapping-it-up","text":"Congratulations, you've successfully created a simple Story app. If you run into any issues or error while following this tutorial, feel free to refer to the source code . I hope this was able to whet your appetite on the possibilities with the Django framework and get your creative juices flowing. Keep up the coding spirit!","title":"Wrapping it Up"}]}